## Aufgabenstellung
#
#   Wirtschaft und Handlessystem einführen
#
#   Der Aufbau erfolgt über 6 Folgen (033-038)
#
#   Folge 33: Auskoppen vorhandern System (Bank und Währung) in eigenes Datapack
#       Themen:
#            - Datapack erstellen
#            - pack.mcmeta
#            - functions
#            - Naming
#
#   Folge 34: Handlessystem: Summon ersten Händler
#       Themen:
#           - summon Villager und Interaction
#           - execute und Enitiy Erkennung
#           - tellraw
#
#   Folge 35: Handlefenster: Ein Dialog für ein Handelsfenster
#       Themen:
#           - Dialog: dialog_list, confirmation
#           - Scoreboard: add, trigger
#           - Trigger
#
#   Folge 36: Handelsfenster: Clear + Macros + Storage + Scoreboards = Werte in Verkauf dynamisch anpassen
#       Themen:
#           - Scoreboards: add, reset
#           - Trigger
#           - Macros
#           - Storage
#           - Clear
#
#   Folge 37: Handelsfenster: Macros + Storage + Scoreboards + Opertation = Werte in Kaufen dynamisch anpassen
#       Themen:
#           - Scoreboards: add, reset, operation
#           - Trigger
#           - Macros
#           - Storage
#
#   Folge 38: Handel: Give + Clear + Storage + Scoreboards + Opertation = Geld und Items
#       Themen:
#           - Scoreboards: add, reset, operation
#           - Clear
#           - Give
#           - Storage


# Aufgabenstellung (Wirstschaftsystem):
Alt: 
    Nur Bank und Währung
Neu:
    Bank, Währung und das Neue Handessystem in ein eigenes Datapack zusammen stellen

# Aufgabenstellung (Nur diese Folge):
Alt: 
    Händler vorhanden, aber noch kein Dialog
Neu:
    Dialog für den Händler erstellen

# Vorgabe:
- Naming: e_s__vendors
- Scoreboard: E_S.


# Nötiges Wissen (Diese Folge)
- Naming
- dialog
- json
- trigger / scoreboard
- interactions

# Links:
Mineraft Wiki:
- https://de.minecraft.wiki/


# Schritte:
- reset aller Trigger erklären, dass noch welche existrieren
- reset_trigger erstellen
- trigger set 0 bei allen triggern
- dialog macro bei max für rottenflesch
- Zeigen, dass Macros in Dialogen probleme machen
- über die interaction als macro festen wert in den dialog geben
- testen ob der Trigger sich ändert
- preparing_for_dialog erstellen
- clear @s item erklären und in preparing_for_dialog einfügen
- clear in scoreboard speichern und erklären, dass wir den Wert nicht in den dialog bekommen
- Storage erklären
- Storage struktur ausfbauen, als kommentar in die Switch
- Storage in preparing_for_dialog beschreiben
- Storage in interaction übergeben
- Testen und Zeigen wenn zuviel, dann Schritte zu groß
- calculate_max_sell erstellen
- function calculate_max_sell nach execute clear einfügen
- calculate_max_sell inhalt erstellen
- testen